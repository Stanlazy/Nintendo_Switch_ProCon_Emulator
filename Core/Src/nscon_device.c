#include "nscon_device.h"
#include <string.h>

/*type dev idx 0*/__ALIGN_BEGIN static const uint8_t nscon_device_desc[18] __ALIGN_END = {0x12,0x01,0x00,0x02,0x00,0x00,0x00,0x40,0x7e,0x05,0x09,0x20,0x10,0x02,0x01,0x02,0x03,0x01};
/*type cfg idx 0*/__ALIGN_BEGIN static const uint8_t nscon_config_desc[41] __ALIGN_END = {0x09,0x02,0x29,0x00,0x01,0x01,0x00,0xa0,0xfa,0x09,0x04,0x00,0x00,0x02,0x03,0x00,0x00,0x00,0x09,0x21,0x11,0x01,0x00,0x01,0x22,0xcb,0x00,0x07,0x05,0x81,0x03,0x40,0x00,0x08,0x07,0x05,0x01,0x03,0x40,0x00,0x08};
/*type hid idx 0*/__ALIGN_BEGIN static const uint8_t nscon_hid_desc[203]   __ALIGN_END = {0x05,0x01,0x15,0x00,0x09,0x04,0xa1,0x01,0x85,0x30,0x05,0x01,0x05,0x09,0x19,0x01,0x29,0x0a,0x15,0x00,0x25,0x01,0x75,0x01,0x95,0x0a,0x55,0x00,0x65,0x00,0x81,0x02,0x05,0x09,0x19,0x0b,0x29,0x0e,0x15,0x00,0x25,0x01,0x75,0x01,0x95,0x04,0x81,0x02,0x75,0x01,0x95,0x02,0x81,0x03,0x0b,0x01,0x00,0x01,0x00,0xa1,0x00,0x0b,0x30,0x00,0x01,0x00,0x0b,0x31,0x00,0x01,0x00,0x0b,0x32,0x00,0x01,0x00,0x0b,0x35,0x00,0x01,0x00,0x15,0x00,0x27,0xff,0xff,0x00,0x00,0x75,0x10,0x95,0x04,0x81,0x02,0xc0,0x0b,0x39,0x00,0x01,0x00,0x15,0x00,0x25,0x07,0x35,0x00,0x46,0x3b,0x01,0x65,0x14,0x75,0x04,0x95,0x01,0x81,0x02,0x05,0x09,0x19,0x0f,0x29,0x12,0x15,0x00,0x25,0x01,0x75,0x01,0x95,0x04,0x81,0x02,0x75,0x08,0x95,0x34,0x81,0x03,0x06,0x00,0xff,0x85,0x21,0x09,0x01,0x75,0x08,0x95,0x3f,0x81,0x03,0x85,0x81,0x09,0x02,0x75,0x08,0x95,0x3f,0x81,0x03,0x85,0x01,0x09,0x03,0x75,0x08,0x95,0x3f,0x91,0x83,0x85,0x10,0x09,0x04,0x75,0x08,0x95,0x3f,0x91,0x83,0x85,0x80,0x09,0x05,0x75,0x08,0x95,0x3f,0x91,0x83,0x85,0x82,0x09,0x06,0x75,0x08,0x95,0x3f,0x91,0x83,0xc0};
/*type str idx 0*/__ALIGN_BEGIN static const uint8_t nscon_lang_desc[4]    __ALIGN_END = {0x04,0x03,0x09,0x04};
/*type str idx 1*/__ALIGN_BEGIN static const uint8_t nscon_mfr_str[38]     __ALIGN_END = {0x26,0x03,0x4e,0x00,0x69,0x00,0x6e,0x00,0x74,0x00,0x65,0x00,0x6e,0x00,0x64,0x00,0x6f,0x00,0x20,0x00,0x43,0x00,0x6f,0x00,0x2e,0x00,0x2c,0x00,0x20,0x00,0x4c,0x00,0x74,0x00,0x64,0x00,0x2e,0x00};
/*type str idx 2*/__ALIGN_BEGIN static const uint8_t nscon_pdt_str[30]     __ALIGN_END = {0x1e,0x03,0x50,0x00,0x72,0x00,0x6f,0x00,0x20,0x00,0x43,0x00,0x6f,0x00,0x6e,0x00,0x74,0x00,0x72,0x00,0x6f,0x00,0x6c,0x00,0x6c,0x00,0x65,0x00,0x72,0x00};
/*type str idx 3*/__ALIGN_BEGIN static const uint8_t nscon_serial_str[26]  __ALIGN_END = {0x1a,0x03,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x31,0x00};

static uint8_t nscon_serial[6];

__ALIGN_BEGIN static NSCON_Report_TypeDef report __ALIGN_END = {.array = {0x30,0x00,0x91, 0x00,0x80,0x00, 0x00,0x08,0x80,0x00,0x08,0x80, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};
__ALIGN_BEGIN static uint8_t buffer[64] __ALIGN_END;
	
static uint8_t allow_report;
static uint8_t was_810100 = 0;
static volatile uint8_t ep1_in_lock = 0;
static struct {
	uint8_t pending;
	uint8_t* cpy_buf;
	uint8_t cpy_len;
} CRdata;

static PCD_HandleTypeDef* this_hpcd;

static const SW_USBD_Callback_Init_TypeDef nscon_callbacks = {
	.Get_Desc = nscon_Get_Desc,
	.Nonstnadard_Setup = nscon_Nonstnadard_Setup,
	.Connected = nscon_Connected,
	.DataInCmplt = nscon_DataIn,
	.DataOutCmplt = nscon_DataOut
};

void nscon_init(PCD_HandleTypeDef *hpcd){
	this_hpcd = hpcd;
	SW_USBD_Init(hpcd, (SW_USBD_Callback_Init_TypeDef*)&nscon_callbacks);
	union {
		uint8_t u8[12];
		uint32_t u32[3];
	} temp;
	temp.u32[0] = HAL_GetUIDw0();
	temp.u32[1] = HAL_GetUIDw1();
	temp.u32[2] = HAL_GetUIDw2();
	for(int i = 0; i < 6; i++){
		nscon_serial[i] = temp.u8[i] ^ temp.u8[i+6];
	}
	memset(&CRdata, 0, sizeof(CRdata));
	allow_report = 0;
	ep1_in_lock = 0;
}

void nscon_seq_timmer_callback(){
	report.seq++;
	if(CRdata.pending && !ep1_in_lock){
		report.type = NSCON_REPORT_TYPE_HANDSHAKE;
		memset(&(report.extra_data[0]), 0, sizeof(report.extra_data));
		memcpy(&(report.extra_data[0]), CRdata.cpy_buf, CRdata.cpy_len);
		ep1_in_lock = 1;
		HAL_PCD_EP_Transmit(this_hpcd, 0x01, report.array, sizeof(report.array));
		memset(&CRdata, 0, sizeof(CRdata));
	}
}

void nscon_copy_report(NSCON_Report_TypeDef* ext){
	memcpy(report.array+3, ext->array+3, 9);
	if(!CRdata.pending && allow_report && !ep1_in_lock){
		memcpy(report.imu, ext->imu, 36);
		HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
		report.type = NSCON_REPORT_TYPE_REPORT;
		ep1_in_lock = 1;
		HAL_PCD_EP_Transmit(this_hpcd, 0x01, report.array, sizeof(report.array));
	}
}

Get_Desc_Retval_TypeDef nscon_Get_Desc(uint8_t bDescType, uint8_t iDescIdx){
	Get_Desc_Retval_TypeDef retval = {NULL, 0};
	switch (bDescType) {
		case USB_DESC_TYPE_DEVICE:       if(!iDescIdx)retval.desc = (uint8_t*)nscon_device_desc; retval.length = sizeof(nscon_device_desc); break;
		case USB_DESC_TYPE_CONFIGURATION:if(!iDescIdx)retval.desc = (uint8_t*)nscon_config_desc; retval.length = sizeof(nscon_config_desc); break;
		case USB_DESC_TYPE_STRING:
			switch (iDescIdx){
				case 0:  retval.desc = (uint8_t*)nscon_lang_desc; retval.length = sizeof(nscon_lang_desc); break;
				case 1:  retval.desc = (uint8_t*)nscon_mfr_str; retval.length = sizeof(nscon_mfr_str); break;
				case 2:  retval.desc = (uint8_t*)nscon_pdt_str; retval.length = sizeof(nscon_pdt_str); break;
				case 3:  retval.desc = (uint8_t*)nscon_serial_str; retval.length = sizeof(nscon_serial_str); break;
				default: break;
			}
		break;
		default: break;
	}
	return retval;
}

void nscon_Nonstnadard_Setup(USB_Request_Packet_TypeDef* request){
	if(request->bmRequestType.recipient == USB_REQUEST_RECIPIENT_INTERFACE && request->bmRequestType.type == USB_REQUEST_TYPE_STANDARD
	&& request->bRequest == USB_STD_DEV_REQ_GET_DESCRIPTOR && request->bDescType == USB_DESC_TYPE_HID_REPORT_DESC && request->iDescIdx == 0){
		SW_USBD_Transfer(0x80, (uint8_t*)nscon_hid_desc, sizeof(nscon_hid_desc));
	} else {
		HAL_PCD_EP_SetStall(this_hpcd, 0x00);
		HAL_PCD_EP_SetStall(this_hpcd, 0x80);
	}
}

void nscon_Connected(){
	HAL_PCD_EP_Open(this_hpcd, 0x01, 64, EP_TYPE_INTR);
	HAL_PCD_EP_Open(this_hpcd, 0x81, 64, EP_TYPE_INTR);
	HAL_PCDEx_SetTxFiFo(this_hpcd, 0x01, 0x40);
	memset(&CRdata, 0, sizeof(CRdata));
	allow_report = 0;
	static const uint8_t nscon_init_810100[] = {0x81,0x01,0x00,0x03};
	memset(buffer, 0, 64);
	memcpy(buffer, nscon_init_810100, sizeof(nscon_init_810100));
	memcpy(buffer+4, nscon_serial, sizeof(nscon_serial));
	ep1_in_lock = 1;
	HAL_PCD_EP_Transmit(this_hpcd, 0x01, buffer, sizeof(buffer));
	was_810100 = 1;
}

void nscon_DataIn(uint8_t epnum){
	if(epnum){
		if(was_810100){
			was_810100 = 0;
			HAL_PCD_EP_Receive(this_hpcd, 0x01, buffer, 64);
		}
		ep1_in_lock = 0;
	}
}

void nscon_DataOut(uint8_t epnum){
	if(epnum){
		if(buffer[0] == 0x01){
			uint32_t length = HAL_PCD_EP_GetRxCount(this_hpcd, epnum);
			if(length == 49) {
				uint8_t flag = 1;
				switch (*((uint16_t*)(&(buffer[10])))){
					case 0x3003:;
						static const uint8_t nscon_init_8003[2] = {0x80,0x03};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8003;
						CRdata.cpy_len = sizeof(nscon_init_8003);
					break;
					case 0x0048: case 0x0148:;
						static const uint8_t nscon_init_8048[2] = {0x80,0x48};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8048;
						CRdata.cpy_len = sizeof(nscon_init_8048);
					break;
					case 0x0002:;
						//                                                                        <BT Mac Addr                ><0x03>
						static       uint8_t nscon_init_8202[14] = {0x82,0x02,0x03,0x48,0x03,0x02,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x02};
						memcpy(nscon_init_8202+6, nscon_serial, sizeof(nscon_serial));
						CRdata.cpy_buf = nscon_init_8202;
						CRdata.cpy_len = sizeof(nscon_init_8202);
					break;
					case 0x0008:;
						static const uint8_t nscon_init_8008[2] = {0x80,0x08};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8008;
						CRdata.cpy_len = sizeof(nscon_init_8008);
					break;
					case 0x0010:;
						static const uint8_t nscon_init_901000[23] = {0x90,0x10,0x00,0x60,0x00,0x00,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
						CRdata.cpy_buf = (uint8_t*)nscon_init_901000;
						CRdata.cpy_len = sizeof(nscon_init_901000);
					break;
					case 0x5010:;
						static const uint8_t nscon_init_901050[19] = {0x90,0x10,0x50,0x60,0x00,0x00,0x0d,0x32,0x32,0x32,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
						CRdata.cpy_buf = (uint8_t*)nscon_init_901050;
						CRdata.cpy_len = sizeof(nscon_init_901050);
					break;
					case 0x0101: case 0x0401:;
						//                                                           <Serial                     >
						static       uint8_t nscon_init_810101[33] = {0x81,0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x25,0x08,0x50,0x72,0x6f,0x20,0x43,0x6f,0x6e,0x74,0x72,0x6f,0x6c,0x6c,0x65,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x68};
						memcpy(nscon_init_810101+3, nscon_serial, sizeof(nscon_serial));
						CRdata.cpy_buf = nscon_init_810101;
						CRdata.cpy_len = sizeof(nscon_init_810101);
					break;
					case 0x0201:;
						//                                                           <Random Number 16Byte                                                         >
						static const uint8_t nscon_init_810102[19] = {0x81,0x01,0x02,0x23,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};
						CRdata.cpy_buf = (uint8_t*)nscon_init_810102;
						CRdata.cpy_len = sizeof(nscon_init_810102);
					break;
					case 0x0301:;
						static const uint8_t nscon_init_810103[3] = {0x81,0x01,0x03};
						CRdata.cpy_buf = (uint8_t*)nscon_init_810103;
						CRdata.cpy_len = sizeof(nscon_init_810103);
					break;
					case 0x0004:;
						static const uint8_t nscon_init_8304[2] = {0x83,0x04};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8304;
						CRdata.cpy_len = sizeof(nscon_init_8304);
					break;
					case 0x8010:;
						static const uint8_t nscon_init_901080[31] = {0x90,0x10,0x80,0x60,0x00,0x00,0x18,0x50,0xfd,0x00,0x00,0xc6,0x0f,0x0f,0x30,0x61,0xae,0x90,0xd9,0xd4,0x14,0x54,0x41,0x15,0x54,0xc7,0x79,0x9c,0x33,0x36,0x63};
						CRdata.cpy_buf = (uint8_t*)nscon_init_901080;
						CRdata.cpy_len = sizeof(nscon_init_901080);
					break;
					case 0x9810:;
						static const uint8_t nscon_init_901098[25] = {0x90,0x10,0x98,0x60,0x00,0x00,0x12,0x0f,0x30,0x61,0xae,0x90,0xd9,0xd4,0x14,0x54,0x41,0x15,0x54,0xc7,0x79,0x9c,0x33,0x36,0x63};
						CRdata.cpy_buf = (uint8_t*)nscon_init_901098;
						CRdata.cpy_len = sizeof(nscon_init_901098);
					break;
					case 0x1010:;
						//                                                                               <Stick Calibration                                   > <Stick Calibration                                   > <IMU    >
						static const uint8_t nscon_init_901010[31] = {0x90,0x10,0x10,0x80,0x00,0x00,0x18,0xb2,0xa1,0xff,0xf7,0x7f,0x00,0x08,0x80,0xff,0xf7,0x7f,0xb2,0xa1,0xff,0xf7,0x7f,0x00,0x08,0x80,0xff,0xf7,0x7f,0xff,0xff};
						CRdata.cpy_buf = (uint8_t*)nscon_init_901010;
						CRdata.cpy_len = sizeof(nscon_init_901010);
					break;
					case 0x3d10:;
						static const uint8_t nscon_init_90103d[32] = {0x90,0x10,0x3d,0x60,0x00,0x00,0x19,0x0c,0x26,0x6c,0x59,0xb8,0x7f,0x33,0xb6,0x5e,0x51,0x98,0x81,0x36,0x16,0x63,0xf9,0xb5,0x63,0xff,0x32,0x32,0x32,0xff,0xff,0xff};
						CRdata.cpy_buf = (uint8_t*)nscon_init_90103d;
						CRdata.cpy_len = sizeof(nscon_init_90103d);
					break;
					case 0x2010: case 0x2810:;
						//                                                     <type     >               <IMU Calibration                                                                        >
						static       uint8_t nscon_init_901020[31] = {0x90,0x10,0xff,0xff,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x3b,0x34,0x3b,0x34,0x3b,0x34};
						if(buffer[11] == 0x20){
							nscon_init_901020[2] = 0x20;
							nscon_init_901020[3] = 0x60;
						} else if(buffer[11] == 0x28){
							nscon_init_901020[2] = 0x28;
							nscon_init_901020[3] = 0x80;
						}
						CRdata.cpy_buf = (uint8_t*)nscon_init_901020;
						CRdata.cpy_len = sizeof(nscon_init_901020);
					break;
					case 0x0140:;
						static const uint8_t nscon_init_8040[2] = {0x80,0x40};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8040;
						CRdata.cpy_len = sizeof(nscon_init_8040);
					break;
					case 0x2121:;
						static const uint8_t nscon_init_a021[36] = {0xa0,0x21,0x01,0x00,0xff,0x00,0x03,0x00,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c};
						CRdata.cpy_buf = (uint8_t*)nscon_init_a021;
						CRdata.cpy_len = sizeof(nscon_init_a021);
					break;
					case 0x0130:;
						static const uint8_t nscon_init_8030[2] = {0x80,0x30};
						CRdata.cpy_buf = (uint8_t*)nscon_init_8030;
						CRdata.cpy_len = sizeof(nscon_init_8030);
					break;
					default:
						flag = 0;
					break;
				}
				if(flag) CRdata.pending = 1;
				else memset(&CRdata, 0, sizeof(CRdata));
			} else if (length == 10){
				
			}
		} else if(buffer[0] == 0x80){
			if(buffer[1] == 0x02){
				static const uint8_t nscon_init_8102[2] = {0x81, 0x02};
				memset(buffer, 0, 64);
				memcpy(buffer, nscon_init_8102, sizeof(nscon_init_8102));
				ep1_in_lock = 1;
				HAL_PCD_EP_Transmit(this_hpcd, epnum, buffer, sizeof(buffer));
			} else if(buffer[1] == 0x04){
				allow_report = 1;
			}
		}
	}
	HAL_PCD_EP_Receive(this_hpcd, 0x01, buffer, 64);
}
